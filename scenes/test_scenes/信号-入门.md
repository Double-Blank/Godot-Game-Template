信号

没问题，我们把这个例子深化一下。

在 Godot 4 中，如果你想在发射信号时传递数据（比如：谁死了？受到了多少伤害？），只需要在 `emit()` 里填入数据，并在接收函数里加上对应的参数即可。

这是修改后的代码，增加了 **“角色名称”** 和 **“剩余生命值”** 两个参数：

### 带参数的代码示例

```gdscript
extends Node

# 1. 定义信号时，建议写上参数名（虽然不写也能运行，但在编辑器里会有提示，更规范）
# 这里定义了两个参数：who (谁) 和 final_hp (剩余血量)
signal health_depleted(who, final_hp)

func _ready():
	# 2. 绑定信号 (写法完全不变)
	health_depleted.connect(_on_game_over)
	
	# 3. 发射信号：在括号里按顺序填入参数
	# 这里我们传了 "玩家1" (String) 和 0 (int)
	health_depleted.emit("玩家1", 0)

# 4. 处理函数：必须接收同样数量的参数
# 注意：函数里的参数名(name, hp)可以和信号定义里的不一样，但顺序必须对应
func _on_game_over(name, hp):
	print("游戏结束！")
	# 使用参数格式化字符串
	print("死者: %s, 剩余血量: %d" % [name, hp])
```

### 输出结果
```text
游戏结束！
死者: 玩家1, 剩余血量: 0
```

---

### 进阶技巧：使用 `.bind()` (非常重要)

有时候信号本身没有参数（比如按钮的 `pressed` 信号），但你希望在触发时**强行**带一个参数过去（比如通过一个通用函数处理多个按钮，想知道是哪个按钮被点了）。

这时可以在 `connect` 的时候使用 `.bind()`。

**场景：** 很多个按钮都连同一个函数，但需要区分是谁。

```gdscript
extends Node

@onready var button_a = $ButtonA
@onready var button_b = $ButtonB

func _ready():
	# 信号本身(pressed)是没有参数的
	# 但是我们通过 bind() 强行绑了一个参数过去
	button_a.pressed.connect(_on_button_click.bind("A按钮"))
	button_b.pressed.connect(_on_button_click.bind("B按钮"))

# 即使 pressed 信号没参数，因为 bind 了数据，这里必须接收这个参数
func _on_button_click(which_button):
	print("你点击了：", which_button)
```

**总结区别：**
1.  **直接传参 (`emit(a, b)`)**：数据是在**发射信号的那一刻**决定的（比如当前的实时血量）。
2.  **绑定参数 (`bind(a)`)**：数据是在**连接信号的那一刻**就定死的（比如按钮的ID）。
