这个需求非常好，这才是信号（Signal）在 Godot 架构中真正的核心用途：**解耦（Decoupling）**。

也就是：**A 只管喊“我出事了”，B 听到后负责处理。A 不需要知道 B 的存在。**

我们设定一个最经典的场景：
1.  **角色 (Player.gd)**：负责扣血，血量变动时发出信号。
2.  **关卡管理器 (Level.gd)**：负责把角色的血量显示在 UI 上，或者判断游戏是否结束。

---

### 场景设置
请想象你的场景树（Scene Tree）是这样的：

```text
┖ Level (挂载 Level.gd)
    ┖ Player (挂载 Player.gd)
```

---

### 文件 1：发射者 (`Player.gd`)

这个脚本只关心角色自己的逻辑。它不知道外面有没有 UI，它只负责“喊”。

```gdscript
# Player.gd
extends Node

# 1. 定义信号：带两个参数 (当前血量, 伤害来源)
signal health_changed(new_hp, damage_source)

var hp = 100

# 这是一个模拟受伤的函数
func take_damage(amount):
    hp -= amount
    if hp < 0:
        hp = 0
    
    # 2. 发射信号：告诉外界“我的血量变了”
    # 注意：Player 不需要知道是谁在听，它只管发。
    health_changed.emit(hp, "火焰陷阱")
    
    print("Player: 我受伤了，现在血量是 ", hp)
```

---

### 文件 2：接收者 (`Level.gd`)

这个脚本是“总管”，它持有 Player 的引用，并负责监听 Player 的动静。

```gdscript
# Level.gd
extends Node

# 获取子节点 Player
@onready var player_node = $Player

func _ready():
    # 1. 跨文件连接信号
    # 语法：发射者节点.信号名.connect(本脚本的处理函数)
    player_node.health_changed.connect(_on_player_health_changed)
    
    # --- 测试代码 ---
    # 我们等待2秒，然后模拟打玩家一下，看看反应
    await get_tree().create_timer(2.0).timeout
    player_node.take_damage(20) # 调用 Player 的函数

# 2. 这是处理函数
# 必须接收 Player 发出的两个参数 (hp, source)
func _on_player_health_changed(current_hp, cause):
    print("\n--- Level 接收到了信号 ---")
    print("UI 更新：玩家被 [%s] 攻击了！" % cause)
    print("UI 更新：血条显示改为 [%d/100]" % current_hp)
    
    if current_hp == 0:
        print("UI 更新：显示 GAME OVER 画面")
```

---

### 运行结果

当你运行这个场景时，控制台会输出：

```text
Player: 我受伤了，现在血量是 80

--- Level 接收到了信号 ---
UI 更新：玩家被 [火焰陷阱] 攻击了！
UI 更新：血条显示改为 [80/100]
```

### 为什么要这么写？（核心价值）

你可能会问：*“为什么不在 `Player.gd` 里直接写 `get_parent().update_ui()` 呢？”*

**坏处（如果直接调用）：**
如果你的 Player 被移动到了另一个没有 `update_ui` 函数的场景里，或者你想单独测试 Player，代码直接就**报错**了。

**好处（使用信号）：**
`Player` 说：“我发信号了，外面有没有人听我不管。”
*   如果有 `Level` 听，UI 就更新。
*   如果没有人听（比如你在单独测试主角），代码依然**完美运行**，不会报错。

这就是**“向下调用（Call Down），向上信号（Signal Up）”**的黄金法则。